\chapter{Integração Redmine e Activiti BPM}\label{chp:integracao_redmine_activiti}


\section{Cenário da Integração}\label{sec:cenario-integracao}

Em cenários de fluxos de trabalho complexos, a utilização de BPMS para automatização de processos de negócio traz diversas vantagens. Dentre essas vantagens, o motor de processos, ao utilizar a notação BPMN, reduz a necessidade de desenvolvimento de funcionalidades específicas que acabam sendo possíveis simplesmente pela modelagem do processo.

Ao inspecionarmos o mercado de soluções BPMS, podemos encontrar diversas opções variando desde soluções pagas caríssimas até soluções gratuitas e de código-fonte aberto. Como exemplo de soluções pagas, podemos citar o SAP NetWeaver BPM e Oracle BPM. Como exemplo de soluções com versões gratuitas ou de código-fonte aberto, podemos citar o Activiti BPM, Bonita BPM, Intalio BPM, Talend BPM.

Em geral, todas as ferramentas de mercado oferecem algum tipo de portal com o usuário, onde a interações humanas com os processos ocorrem. No portal, o usuário pode interagir com os processos, atuando em tarefas a ele designadas, ou abrindo novos processos, entre outras possibilidades de interação. 

A maioria das ferramentas também oferecem algum tipo de API de forma que seja possível aproveitar os benefícios da BPMS, mas utilizando a interface com o usuário que seja mais adequada. Isso possibilita a extensão do BPMS para outras plataformas não tradicionais em ambientes corporativos, como os dispositivos móveis ou até mesmo sensores, ou mesmo a customização de um novo portal que atenda as necessidades da corporação.

Com o objetivo de evoluir o Redmine para o atendimento de fluxos de trabalho mais complexos, torna-se necessário o desenvolvimento de um motor de processos mais robusto e que possibilite novas opções e configurações de fluxos na ferramenta. Entretanto, ao avaliarmos a quantidade de possibilidades de fluxos de trabalho imagináveis, o desenvolvimento de uma solução desse porte acaba por convergir em um problema já solucionado atualmente por ferramentas BPMS. Nesse sentido, torna-se interessante propor uma solução integrada que aproveite as vantagens de interface e configuração do Redmine, mas que também aproveite todo o poder de modelagem e flexibilidade oferecidos por ferramentas BPMS. Nasce assim a ideia de propor a integração do Redmine com o BPM.

\section{Integração Genérica}\label{sec:cenario-integracao-genérica}

Pensando na possibilidade de utilização de qualquer plataforma BPMS integrada ao Redmine, decidimos avaliar a utilização de ferramentas ESB (Enterprise Service Bus) de forma a facilitar a construção de uma interface única de comunicação com o Redmine. Sendo assim, bastaria o trabalho de integrar o BPM escolhido com este barramento, e assim o Redmine estaria capacitado a orquestrar fluxos de trabalho mais complexos.

Nesse contexto, a dificuldade consistia na especificação de uma interface que atendesse às funcionalidades disponíveis nos diversos BPMS. Entretanto, ao avaliar algumas APIs de BPM disponíveis no mercado, como por exemplo a API do Activiti BPM, Bonita BPM e Intalio BPM,  percebemos que desviaríamos completamente o foco do trabalho, que era a extensão do Redmine e passaríamos a complexidade do trabalho para a integração. Nesse sentido, decidimos abortar a construção dessa interface genérica e partirmos para uma solução de menor complexidade, mas que possibilitasse o ganho imaginado com a integração do BPM ao Redmine.

\section{Integração Activiti}\label{sec:cenario-integracao-activiti}

Dado a complexidade de criação dessa interface genérica, decidimos desenvolver a integração do Redmine com um BPMS específico de mercado. Nesse cenário, diversas dificuldades envolvidas ao processo de generalização deixaram de ser preocupação, e permitiram que o desenvolvimento fosse mais focado na solução do problema inicial, que é trazer mais flexibilidade e alternativas de fluxo de trabalho para o Redmine.

Sendo assim, foi necessário definir um BPMS de mercado que atendesse a alguns critérios. O motor deveria ser gratuito e de código aberto, estando assim alinhado com a proposta open-source do Redmine. Além disso, seria fundamental que a ferramenta fosse leve, extensível e com uma API de fácil utilização e documentação, possibilitando assim um rápido entendimento da plataforma e abertura para qualquer modificação ou extensão necessária na ferramenta. Seria desejável também que a ferramenta estivesse em constante evolução e fosse suportado por uma comunidade ativa e que pudesse oferecer suporte para dúvidas encontradas durante o processo de integração.

Ao avaliarmos as possibilidades, identificamos uma ferramenta que se encaixava bastante nos critérios adotados, o Activiti BPM. O Activiti BPM possui APIs em Java e REST, e para a comunicação com o Redmine, que é escrito em Ruby on Rails, faria mais sentido a utilização da interface REST.

\section{Customização do Redmine}\label{sec:integracao_redmine_activiti-implementacao}

Para atingir este objetivo, criamos um plugin para o Redmine que possibilita a comunicação com o Activiti. Nas próximas sessões, descreveremos o processo de construção deste plugin e como utilizá-lo.

A integração tem por objetivo centralizar o máximo de funcionalidades no Redmine, deixando transparente tanto para o usuário comum como o gestor, a existência de um motor BPM por trás.

\subsection{Linguagens}\label{sec:integracao_redmine_activiti_implementacao_detalhes_desenvolvimento_linguagens}

O plugin desenvolvido para Redmine foi desenvolvido em Ruby\cite{ruby-lang}, utilizando a framework Rails\cite{rails}. A linguagem open source e orientada a objetos, disponibilizada ao público em 1995, foi criada por Yukihiro “Matz” Matsumoto, inspirada nas linguagens Perl, Smalltalk, Eiffel, Ada e Lisp, suas linguagens preferidas. Em 2006, o Ruby atingiu aceitação massiva, com a formação de grupos de usuários em todas as principais cidades do mundo e com as conferências sobre Ruby com lotação esgotada. Ruby está entre as 10 linguagens mais populares, segundo o índice TIOBE\cite{tiobe} de abril de 2016, que se baseia nas buscas com o nome da linguagem como palavra chave. A framework Rails é uma biblioteca (ou gema) que extende de Ruby. Foi criada por David Heinemeier Hansson em 2004 para a utilização desta linguagem para o desenvolvimento de aplicações web. Isto é feito através da comunicação da comunicação do Ruby com HTML, CSS e Javascript.

As modificações feitas no Activiti foram feitas em Java, a linguagem que em que este foi desenvolvido. Criado em 1995 por um time da Sun (chamado de "Green Team"), Java\cite{java-history} é uma linguagem interpretada orientada a objetos,  que é independente de plataforma, pois sempre executa na JVM (Java Virtual Machine). Segundo o índice TIOBE de abril de 2016 é a linguagem mais popular no mundo.

\subsection{Banco de dados}\label{sec:integracao_redmine_activiti_implementacao__bd}

O banco de dados utilizado neste trabalho foi o Mysql 5.7. Este é o banco mais utilizado e testado com o Redmine pela comunidade.

\subsection{Sincronização}\label{sec:integracao_redmine_activiti_implementacao_sincronizacao}

Para possibilitar a comunicação entre o Activiti BPM e o Redmine foi desenvolvido um mecanismo de sincronização.
Toda a comunicação foi desenhada de forma que o Redmine funcionasse como uma interface do Activiti. Portanto, o primeiro sempre consome a API REST do BPMS para disparar ações, ou ler informações do mesmo.

\subsubsection{Definição de processo}

Ao fazer o deploy de um processo através da interface do Redmine é disparado um serviço que acessa a API REST do Activiti, executando uma requisição POST que efetivamente executa o deploy, adicionando a modelagem do processo em questão à lista de definições de processos ativos, que podem ser iniciados.

O código a seguir monta a requisição POST repository/deployments enviando o arquivo .bpmn, que retorna o deployment\_id do processo cujo deploy acaba de ser feito.

\codejava{Ruby}{alg:LABEL_CODE_5}{codigos/deploy_process.rb}


Após executado o serviço, é iniciado um job que busca a definição à partir do deployment\_id. As informações do processo que são recuperadas consistem das tarefas humanas definidas, campos de formulário, variáveis de processo e outros detalhes.

O código a seguir monta a requisição GET que recupera a definição de um processo.

\codejava{Ruby}{alg:LABEL_CODE_4}{codigos/process_definition_by_deployment_id.rb}

O código a seguir consiste do job que centraliza a sincronização de uma definição de processo no momento do deploy. 

\codejava{Ruby}{alg:LABEL_CODE_3}{codigos/sinchronize_process_definition_job.rb}

\subsubsection{Inicialização de um processo}\label{sec:integracao_redmine_activiti_sincronizacao_inicializacao_processo}
Sempre que uma tarefa é criada, caso ela esteja vinculada a um processo BPM (configuração provida pelo plugin), um serviço é disparado. Este serviço executa uma requisição POST à API REST do Activiti, que dispara uma nova instancia de um processo no mesmo. A requisição carrega as informações da tarefa a ser criada, inclusive os valores dos campos customizados, que foram mapeados para algum campo de formulário da definição de processo do BPMS.

\subsubsection{Tarefas humanas}\label{sec:integracao_redmine_activiti_implementacao_detalhes_desenvolvimento_sincronizacao_human_task}

Como dito anteriormente no capítulo  \ref{chp:automatizacao_processos}, as tarefas humanas do Activiti são representadas no Redmine por subtarefas das tarefas que representam processos. Assumimos que todo processo do Activiti configurado no Redmine possui tarefas humanas, uma vez que o principal objetivo é ajudar o usuário a interagir com o processo.
Quando uma tarefa humana é criada no decorrer do processo, o Redmine precisa refletir isto, de modo que esta tarefa possa ser executada pelo ator correto e o processo siga seu curso. O espelhamento desta tarefa no Redmine é totalmente automatizado, através de um job que roda a cada 5 minutos e verifica se existem tarefas humanas abertas que não foram espelhadas, para cada processo ativo no Redmine.
Abaixo é possível visualizar o código desse job:

\codejava{Ruby}{alg:LABEL_CODE_4}{codigos/sync_bpm_tasks_job.rb}

\section{Customização do Activiti}\label{sec:integracao_redmine_activiti-implementacao-activiti}

A integração entre o Redmine e o Activiti BPM foi desenvolvida sob o aspecto de direcionar a maior parte das customizações para o lado do Redmine, uma vez que esta é apenas uma das possibilidades de interface com o motor de processos. Num cenário mais amplo de processos mais complexos, outros tipos de dispositivos ou sistemas poderiam realizar uma comunicação direta com os processos.

A API REST padrão oferecida pelo Activiti foi utilizada para a integração entre as ferramentas, uma vez que é bem completa e oferece a maioria dos serviços necessários para a comunicação. Também contou a facilidade de chamadas a APIs REST pelo Ruby on Rails. 

Entretanto, identificamos a ausência de um serviço fundamental para integração entre as ferramentas. Esse serviço deveria retornar uma lista contendo as definições de tarefas contidas em um determinado processo, incluindo os campos disponíveis nos formulários das tarefas. Essa definição nos permitiria estabelecer a interface para o mapeamento dos campos do processo com os campos das tarefas do Redmine.

Sendo assim, extendemos a API REST do Activiti, através da criação de um classe Java representando um novo serviço, semelhante aos serviços existentes no seu código-fonte. Esse serviço consistiu no consumo de uma API Java já disponibilizada pelo Activiti, mas ausente na API REST. O código-fonte simplificado desta classe pode ser observado abaixo:

\codejava{Java}{alg:LABEL_CODE_2}{codigos/TaskDefinitionService.java}

\section{Resultados}\label{sec:integracao_redmine_activiti-resultados}